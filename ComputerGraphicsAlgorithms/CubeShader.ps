#include "Light.h"

struct ModelBuffer {
    float4x4 model;
    float4x4 norm;
    // x - shininess
    // y - rotation speed
    // z - texture id
    // w - normal map presence
    float4 shineSpeedTexIdNM;
    // xyz - position
    // w - current angle
    float4 posAngle;
};

cbuffer ModelBufferInst : register (b1) {
    ModelBuffer modelBuffer[100];
};

cbuffer ModelBufferInstVis : register (b2) {
    uint4 ids[100];
};

Texture2DArray colorTexture : register (t0);
Texture2D normalMapTexture : register (t1);

SamplerState colorSampler : register(s0);

struct VSOutput {
    float4 pos : SV_Position;
    float4 worldPos : POSITION;
    float3 tang : TANGENT;
    float3 norm : NORMAL;
    float2 uv : TEXCOORD;

    nointerpolation unsigned int instanceId : SV_InstanceID;
};

float4 ps(VSOutput pixel) : SV_Target0 {
    unsigned int idx = lightsBumpNormsCull.w == 1 ? ids[pixel.instanceId].x : pixel.instanceId;
    unsigned int flags = asuint(modelBuffer[idx].shineSpeedTexIdNM.w);

    float3 color = colorTexture.Sample(colorSampler, float3(pixel.uv, modelBuffer[idx].shineSpeedTexIdNM.z)).xyz;
    float3 finalColor = ambientColor * color;

    float3 normal = float3(0,0,0);
    if (lightsBumpNormsCull.y > 0 && flags == 1)
    {
        float3 binorm = normalize(cross(pixel.norm, pixel.tang));
        float3 localNorm = normalMapTexture.Sample(colorSampler, pixel.uv).xyz * 2.0 - float3(1.0, 1.0, 1.0);
        normal = localNorm.x * normalize(pixel.tang) + localNorm.y * binorm + localNorm.z * normalize(pixel.norm);
    }
    else
    {
        normal = pixel.norm;
    }

    return float4(CalculateColor(color, normal, pixel.worldPos.xyz, modelBuffer[idx].shineSpeedTexIdNM.x, false), 1.0);
}
